import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.CQuhCYrb.js";const g=JSON.parse('{"title":"Node.js 全栈开发核心资料与高频面试题","description":"","frontmatter":{},"headers":[],"relativePath":"notes/技术/Node.js 全栈开发核心资料与高频面试题.md","filePath":"notes/技术/Node.js 全栈开发核心资料与高频面试题.md","lastUpdated":1764827213000}'),l={name:"notes/技术/Node.js 全栈开发核心资料与高频面试题.md"};function t(h,s,r,o,p,k){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="node-js-全栈开发核心资料与高频面试题" tabindex="-1">Node.js 全栈开发核心资料与高频面试题 <a class="header-anchor" href="#node-js-全栈开发核心资料与高频面试题" aria-label="Permalink to &quot;Node.js 全栈开发核心资料与高频面试题&quot;">​</a></h1><h2 id="第一部分-node-js-学习资料与路线图" tabindex="-1">第一部分：Node.js 学习资料与路线图 <a class="header-anchor" href="#第一部分-node-js-学习资料与路线图" aria-label="Permalink to &quot;第一部分：Node.js 学习资料与路线图&quot;">​</a></h2><h3 id="_1-核心基础-foundations" tabindex="-1">1. 核心基础 (Foundations) <a class="header-anchor" href="#_1-核心基础-foundations" aria-label="Permalink to &quot;1. 核心基础 (Foundations)&quot;">​</a></h3><p>在深入框架之前，必须掌握 Node.js 的原生能力。</p><ul><li><strong>运行时原理</strong>：V8 引擎、Libuv 库、单线程模型、非阻塞 I/O。</li><li><strong>模块系统</strong>：CommonJS (<code>require/module.exports</code>) 与 ES Modules (<code>import/export</code>) 的区别与互操作。</li><li><strong>内置模块</strong>： <ul><li><code>fs</code> (文件系统)：读写文件、流式操作。</li><li><code>http/https</code>：创建服务器、发起请求。</li><li><code>path</code>：路径处理。</li><li><code>events</code>：发布订阅模式核心。</li><li><code>stream</code>：流的处理（四种流类型）。</li><li><code>buffer</code>：二进制数据处理。</li></ul></li></ul><h3 id="_2-异步编程-asynchronous-programming" tabindex="-1">2. 异步编程 (Asynchronous Programming) <a class="header-anchor" href="#_2-异步编程-asynchronous-programming" aria-label="Permalink to &quot;2. 异步编程 (Asynchronous Programming)&quot;">​</a></h3><ul><li><strong>回调函数 (Callbacks)</strong>：错误优先风格 (Error-first)。</li><li><strong>Promise</strong>：状态机、链式调用、<code>Promise.all/race/allSettled</code>。</li><li><strong>Async/Await</strong>：同步写法的异步代码，错误捕获 (<code>try-catch</code>)。</li><li><strong>事件循环 (Event Loop)</strong>：宏任务 (MacroTask) vs 微任务 (MicroTask)，<code>process.nextTick</code> vs <code>setImmediate</code>。</li></ul><h3 id="_3-web-框架-frameworks" tabindex="-1">3. Web 框架 (Frameworks) <a class="header-anchor" href="#_3-web-框架-frameworks" aria-label="Permalink to &quot;3. Web 框架 (Frameworks)&quot;">​</a></h3><ul><li><strong>Express</strong>：老牌、生态丰富、中间件线性模型。</li><li><strong>Koa2</strong>：轻量级、基于 async/await、洋葱圈模型 (Onion Model)。</li><li><strong>NestJS</strong>：Angular 风格、TypeScript 支持、依赖注入 (IoC)、适合大型企业级应用。</li><li><strong>Fastify</strong>：主打高性能、低开销。</li></ul><h3 id="_4-数据库与缓存-database-cache" tabindex="-1">4. 数据库与缓存 (Database &amp; Cache) <a class="header-anchor" href="#_4-数据库与缓存-database-cache" aria-label="Permalink to &quot;4. 数据库与缓存 (Database &amp; Cache)&quot;">​</a></h3><ul><li><strong>NoSQL</strong>: MongoDB (配合 Mongoose)。</li><li><strong>SQL</strong>: MySQL/PostgreSQL (配合 Sequelize, TypeORM 或 Prisma)。</li><li><strong>Cache</strong>: Redis (缓存策略、Session 存储、消息队列)。</li></ul><h3 id="_5-进阶与运维-advanced-devops" tabindex="-1">5. 进阶与运维 (Advanced &amp; DevOps) <a class="header-anchor" href="#_5-进阶与运维-advanced-devops" aria-label="Permalink to &quot;5. 进阶与运维 (Advanced &amp; DevOps)&quot;">​</a></h3><ul><li><strong>多进程</strong>: <code>child_process</code>, <code>cluster</code> 模块。</li><li><strong>性能调优</strong>: 内存泄漏排查 (Heap dump), CPU Profiling。</li><li><strong>进程管理</strong>: PM2 (负载均衡、日志管理、自动重启)。</li><li><strong>部署</strong>: Docker, CI/CD, Nginx 反向代理。</li></ul><h3 id="_6-推荐书籍与资源" tabindex="-1">6. 推荐书籍与资源 <a class="header-anchor" href="#_6-推荐书籍与资源" aria-label="Permalink to &quot;6. 推荐书籍与资源&quot;">​</a></h3><ul><li><strong>入门</strong>: 《Node.js 实战 (Node.js in Action)》</li><li><strong>进阶</strong>: 《深入浅出 Node.js》 (朴灵 著) —— 经典中的经典，必读。</li><li><strong>设计模式</strong>: 《Node.js Design Patterns》</li><li><strong>文档</strong>: <a href="https://nodejs.org/en/docs/" target="_blank" rel="noreferrer">Node.js 官方文档</a></li></ul><hr><h2 id="第二部分-node-js-高频面试题-附简要答案" tabindex="-1">第二部分：Node.js 高频面试题 (附简要答案) <a class="header-anchor" href="#第二部分-node-js-高频面试题-附简要答案" aria-label="Permalink to &quot;第二部分：Node.js 高频面试题 (附简要答案)&quot;">​</a></h2><h3 id="一、-基础概念与原理" tabindex="-1">一、 基础概念与原理 <a class="header-anchor" href="#一、-基础概念与原理" aria-label="Permalink to &quot;一、 基础概念与原理&quot;">​</a></h3><h4 id="_1-什么是-node-js-它有什么特点" tabindex="-1">1. 什么是 Node.js？它有什么特点？ <a class="header-anchor" href="#_1-什么是-node-js-它有什么特点" aria-label="Permalink to &quot;1. 什么是 Node.js？它有什么特点？&quot;">​</a></h4><ul><li><strong>定义</strong>: Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。</li><li><strong>特点</strong>: <ol><li><strong>事件驱动 (Event-driven)</strong>。</li><li><strong>非阻塞 I/O (Non-blocking I/O)</strong>。</li><li><strong>单线程 (Single Threaded)</strong>：主线程是单线程，但底层 Libuv 线程池处理耗时 I/O。</li><li><strong>轻量高效</strong>：适合 I/O 密集型应用，不适合 CPU 密集型。</li></ol></li></ul><h4 id="_2-node-js-的-event-loop-事件循环-运行机制是怎样的-★重点" tabindex="-1">2. Node.js 的 Event Loop (事件循环) 运行机制是怎样的？(★重点) <a class="header-anchor" href="#_2-node-js-的-event-loop-事件循环-运行机制是怎样的-★重点" aria-label="Permalink to &quot;2. Node.js 的 Event Loop (事件循环) 运行机制是怎样的？(★重点)&quot;">​</a></h4><p>Node.js 的事件循环与浏览器不同，分为 6 个阶段，循环执行：</p><ol><li><strong>Timers</strong>: 执行 <code>setTimeout</code> 和 <code>setInterval</code> 的回调。</li><li><strong>Pending Callbacks</strong>: 执行系统操作的回调（如 TCP 错误）。</li><li><strong>Idle, Prepare</strong>: 内部使用。</li><li><strong>Poll</strong>: 获取新的 I/O 事件，执行 I/O 回调（核心阶段）。</li><li><strong>Check</strong>: 执行 <code>setImmediate</code> 的回调。</li><li><strong>Close Callbacks</strong>: 执行关闭事件的回调（如 <code>socket.on(&#39;close&#39;)</code>）。</li></ol><ul><li><strong>微任务</strong>: <code>process.nextTick</code> 优先级最高，在当前阶段结束前立即执行；Promise 的 <code>then</code> 在 nextTick 之后。</li></ul><h4 id="_3-process-nexttick-和-setimmediate-的区别" tabindex="-1">3. <code>process.nextTick</code> 和 <code>setImmediate</code> 的区别？ <a class="header-anchor" href="#_3-process-nexttick-和-setimmediate-的区别" aria-label="Permalink to &quot;3. \`process.nextTick\` 和 \`setImmediate\` 的区别？&quot;">​</a></h4><ul><li><code>process.nextTick</code>: 属于微任务，在当前操作完成后、事件循环的下一个阶段开始前<strong>立即</strong>执行。优先级极高，如果递归调用会导致 IO 饥饿。</li><li><code>setImmediate</code>: 属于宏任务，在事件循环的 <strong>Check</strong> 阶段执行。</li></ul><h4 id="_4-commonjs-和-es-modules-esm-的区别" tabindex="-1">4. CommonJS 和 ES Modules (ESM) 的区别？ <a class="header-anchor" href="#_4-commonjs-和-es-modules-esm-的区别" aria-label="Permalink to &quot;4. CommonJS 和 ES Modules (ESM) 的区别？&quot;">​</a></h4><ul><li><strong>CommonJS</strong>: <ul><li>语法: <code>require</code>, <code>module.exports</code>。</li><li>加载: <strong>运行时加载</strong>，同步加载。</li><li>输出: 输出的是值的<strong>拷贝</strong> (基本类型) 或引用 (对象)。</li></ul></li><li><strong>ESM</strong>: <ul><li>语法: <code>import</code>, <code>export</code>。</li><li>加载: <strong>编译时输出接口</strong>，异步加载。</li><li>输出: 输出的是值的<strong>引用</strong> (Live Binding)。</li></ul></li></ul><hr><h3 id="二、-核心模块与-api" tabindex="-1">二、 核心模块与 API <a class="header-anchor" href="#二、-核心模块与-api" aria-label="Permalink to &quot;二、 核心模块与 API&quot;">​</a></h3><h4 id="_5-buffer-是什么-为什么要使用它" tabindex="-1">5. Buffer 是什么？为什么要使用它？ <a class="header-anchor" href="#_5-buffer-是什么-为什么要使用它" aria-label="Permalink to &quot;5. Buffer 是什么？为什么要使用它？&quot;">​</a></h4><ul><li><strong>定义</strong>: Buffer 是用于处理二进制数据的类。因为 JS 早期只有字符串，没有二进制数据类型。</li><li><strong>场景</strong>: 文件流操作、TCP 流、网络通信、加密算法。</li><li><strong>内存</strong>: Buffer 内存是在 V8 堆外分配的 (C++层面)，不由 V8 GC 直接管理。</li></ul><h4 id="_6-stream-流-有哪几种类型-有什么优势" tabindex="-1">6. Stream (流) 有哪几种类型？有什么优势？ <a class="header-anchor" href="#_6-stream-流-有哪几种类型-有什么优势" aria-label="Permalink to &quot;6. Stream (流) 有哪几种类型？有什么优势？&quot;">​</a></h4><ul><li><strong>类型</strong>: <ol><li><code>Readable</code>: 可读流 (如 <code>fs.createReadStream</code>).</li><li><code>Writable</code>: 可写流 (如 <code>fs.createWriteStream</code>).</li><li><code>Duplex</code>: 双工流 (可读可写，如 TCP Socket).</li><li><code>Transform</code>: 转换流 (读入数据，转换后输出，如 <code>zlib</code>, <code>crypto</code>).</li></ol></li><li><strong>优势</strong>: 内存效率高（不需要一次性把大文件加载到内存）、时间效率高（边读边写）。</li></ul><h4 id="_7-eventemitter-是同步还是异步的" tabindex="-1">7. EventEmitter 是同步还是异步的？ <a class="header-anchor" href="#_7-eventemitter-是同步还是异步的" aria-label="Permalink to &quot;7. EventEmitter 是同步还是异步的？&quot;">​</a></h4><ul><li>默认是 <strong>同步</strong> 的。当触发事件 (<code>emit</code>) 时，监听器 (<code>on</code>) 会按照注册顺序依次同步执行。</li><li>如果在监听器中包含异步操作（如 <code>setImmediate</code>），则该操作是异步的。</li></ul><h4 id="_8-require-的加载机制是怎样的" tabindex="-1">8. require 的加载机制是怎样的？ <a class="header-anchor" href="#_8-require-的加载机制是怎样的" aria-label="Permalink to &quot;8. require 的加载机制是怎样的？&quot;">​</a></h4><ol><li><strong>缓存检查</strong>: 先检查 <code>Module._cache</code>，有缓存直接返回。</li><li><strong>路径分析</strong>: 是核心模块？相对路径？绝对路径？还是第三方模块 (node_modules)?</li><li><strong>文件定位</strong>: 尝试补全扩展名 <code>.js</code> -&gt; <code>.json</code> -&gt; <code>.node</code>。</li><li><strong>编译执行</strong>: 根据文件类型载入，包装成一个函数执行 (注入 <code>exports</code>, <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code>)。</li><li><strong>缓存</strong>: 将结果缓存。</li></ol><hr><h3 id="三、-web-框架与工程化" tabindex="-1">三、 Web 框架与工程化 <a class="header-anchor" href="#三、-web-框架与工程化" aria-label="Permalink to &quot;三、 Web 框架与工程化&quot;">​</a></h3><h4 id="_9-express-和-koa-的中间件机制有什么区别" tabindex="-1">9. Express 和 Koa 的中间件机制有什么区别？ <a class="header-anchor" href="#_9-express-和-koa-的中间件机制有什么区别" aria-label="Permalink to &quot;9. Express 和 Koa 的中间件机制有什么区别？&quot;">​</a></h4><ul><li><strong>Express</strong>: 线性模型。中间件依次执行，<code>next()</code> 调用下一个，主要用于逻辑分离。如果中间件中有异步操作，Express 默认不会等待异步完成就返回响应（除非特殊处理）。</li><li><strong>Koa</strong>: 洋葱圈模型 (Onion Model)。基于 <code>async/await</code>。 <ul><li><strong>入</strong>: 请求经过中间件，<code>await next()</code> 暂停当前中间件，进入下一个。</li><li><strong>出</strong>: 最内层执行完后，逆序返回，执行 <code>await next()</code> 之后的代码。适合处理响应时间的统计、日志记录等。</li></ul></li></ul><h4 id="_10-什么是-nestjs-它解决了什么问题" tabindex="-1">10. 什么是 NestJS？它解决了什么问题？ <a class="header-anchor" href="#_10-什么是-nestjs-它解决了什么问题" aria-label="Permalink to &quot;10. 什么是 NestJS？它解决了什么问题？&quot;">​</a></h4><ul><li>基于 TypeScript，引入了 OOP (面向对象)、FP (函数式) 和 FRP (函数响应式) 的理念。</li><li><strong>核心</strong>: 依赖注入 (Dependency Injection)，模块化 (Modules)，装饰器 (Decorators)。</li><li><strong>解决</strong>: Express/Koa 架构过于自由导致的“千人千面”难以维护的问题，提供了标准的架构规范，适合大型企业级应用。</li></ul><hr><h3 id="四、-性能与运维" tabindex="-1">四、 性能与运维 <a class="header-anchor" href="#四、-性能与运维" aria-label="Permalink to &quot;四、 性能与运维&quot;">​</a></h3><h4 id="_11-node-js-如何利用多核-cpu-cluster-模块" tabindex="-1">11. Node.js 如何利用多核 CPU？(Cluster 模块) <a class="header-anchor" href="#_11-node-js-如何利用多核-cpu-cluster-模块" aria-label="Permalink to &quot;11. Node.js 如何利用多核 CPU？(Cluster 模块)&quot;">​</a></h4><ul><li>Node.js 是单线程的，默认只用一个 CPU 核心。</li><li>可以使用 <code>cluster</code> 模块或 <code>pm2</code> 工具开启多个子进程 (Worker)。</li><li><strong>原理</strong>: Master 进程负责监听端口和分发请求（通常使用 Round-Robin 算法），Worker 进程负责处理业务逻辑。Worker 之间通过 IPC (进程间通信) 通信。</li></ul><h4 id="_12-常见的内存泄漏场景有哪些-如何排查" tabindex="-1">12. 常见的内存泄漏场景有哪些？如何排查？ <a class="header-anchor" href="#_12-常见的内存泄漏场景有哪些-如何排查" aria-label="Permalink to &quot;12. 常见的内存泄漏场景有哪些？如何排查？&quot;">​</a></h4><ul><li><strong>场景</strong>: <ol><li>全局变量无限制增加。</li><li>闭包引用未释放。</li><li>事件监听器 (<code>on</code>) 只注册不移除 (<code>off</code>)。</li><li>缓存 (如用对象当缓存) 无过期策略。</li></ol></li><li><strong>排查</strong>: <ul><li>使用 <code>chrome://inspect</code> 连接 Node 进程。</li><li>使用 <code>heapdump</code> 导出内存快照。</li><li>对比不同时间段的 Heap Snapshot，查找 Retained Size 异常的对象。</li></ul></li></ul><h4 id="_13-如何处理高并发" tabindex="-1">13. 如何处理高并发？ <a class="header-anchor" href="#_13-如何处理高并发" aria-label="Permalink to &quot;13. 如何处理高并发？&quot;">​</a></h4><ol><li><strong>负载均衡</strong>: Nginx 前置反向代理。</li><li><strong>集群模式</strong>: PM2 开启 Cluster 模式。</li><li><strong>缓存</strong>: Redis 缓存热点数据。</li><li><strong>异步非阻塞</strong>: 充分利用 Node.js 特性，避免在主线程进行 CPU 密集型计算（如图像处理、大循环）。</li><li><strong>分离计算</strong>: CPU 密集任务交给 Worker Threads 或 独立的微服务（Go/Java/C++）。</li></ol><h4 id="_14-什么是守护进程-pm2-的作用" tabindex="-1">14. 什么是守护进程？PM2 的作用？ <a class="header-anchor" href="#_14-什么是守护进程-pm2-的作用" aria-label="Permalink to &quot;14. 什么是守护进程？PM2 的作用？&quot;">​</a></h4><ul><li><strong>守护进程</strong>: 在后台运行，不与终端交互，系统关闭时才停止的进程。</li><li><strong>PM2</strong>: <ul><li>进程守护（崩溃自动重启）。</li><li>负载均衡（Cluster Mode）。</li><li>日志管理。</li><li>监控（CPU/内存使用率）。</li></ul></li></ul><hr><h3 id="五、-代码题-live-coding-常见" tabindex="-1">五、 代码题 (Live Coding 常见) <a class="header-anchor" href="#五、-代码题-live-coding-常见" aria-label="Permalink to &quot;五、 代码题 (Live Coding 常见)&quot;">​</a></h3><h4 id="_15-手写一个简单的-event-emitter" tabindex="-1">15. 手写一个简单的 Event Emitter <a class="header-anchor" href="#_15-手写一个简单的-event-emitter" aria-label="Permalink to &quot;15. 手写一个简单的 Event Emitter&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEventEmitter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">listener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(listener);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">listener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[type].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> listener);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">listener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wrapper</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      listener.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, wrapper);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, wrapper);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_16-手写实现一个简单的-sleep-函数" tabindex="-1">16. 手写实现一个简单的 sleep 函数 <a class="header-anchor" href="#_16-手写实现一个简单的-sleep-函数" aria-label="Permalink to &quot;16. 手写实现一个简单的 sleep 函数&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Promise 版本</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, ms));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;End&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})();</span></span></code></pre></div>`,60)])])}const c=i(l,[["render",t]]);export{g as __pageData,c as default};

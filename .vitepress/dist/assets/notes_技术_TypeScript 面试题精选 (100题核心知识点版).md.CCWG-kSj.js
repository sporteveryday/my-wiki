import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.CQuhCYrb.js";const c=JSON.parse('{"title":"TypeScript 面试题精选 (100题核心知识点版)","description":"","frontmatter":{},"headers":[],"relativePath":"notes/技术/TypeScript 面试题精选 (100题核心知识点版).md","filePath":"notes/技术/TypeScript 面试题精选 (100题核心知识点版).md","lastUpdated":null}'),n={name:"notes/技术/TypeScript 面试题精选 (100题核心知识点版).md"};function l(p,s,h,o,r,d){return t(),a("div",null,[...s[0]||(s[0]=[e(`<p>作为一个人工智能语言模型，我无法直接向你发送一个可下载的 PDF 文件。</p><p>不过，为了帮助你备战面试，我为你整理了一份<strong>精选的 TypeScript 面试题集（涵盖基础到高级）</strong>。你可以将以下内容复制到 Word、Markdown 或 Notion 中，然后导出为 PDF 进行阅读。</p><p>这份题集涵盖了从基础概念、类型系统到高级泛型和工具类型的核心知识点。</p><hr><h1 id="typescript-面试题精选-100题核心知识点版" tabindex="-1">TypeScript 面试题精选 (100题核心知识点版) <a class="header-anchor" href="#typescript-面试题精选-100题核心知识点版" aria-label="Permalink to &quot;TypeScript 面试题精选 (100题核心知识点版)&quot;">​</a></h1><h2 id="第一部分-typescript-基础-basics" tabindex="-1">第一部分：TypeScript 基础 (Basics) <a class="header-anchor" href="#第一部分-typescript-基础-basics" aria-label="Permalink to &quot;第一部分：TypeScript 基础 (Basics)&quot;">​</a></h2><p><strong>1. 什么是 TypeScript？它与 JavaScript 有什么区别？</strong></p><ul><li><strong>答案：</strong> TypeScript 是 JavaScript 的超集，由微软开发。它在 JavaScript 的基础上添加了静态类型系统（Static Typing）和基于类的面向对象编程特性。</li><li><strong>区别：</strong><ul><li>TS 需要编译（Transpile）成 JS 才能在浏览器运行。</li><li>TS 提供了静态类型检查，可以在编译阶段发现错误。</li><li>TS 支持接口（Interfaces）、泛型（Generics）等高级特性。</li></ul></li></ul><p><strong>2. 为什么要使用 TypeScript？（优缺点）</strong></p><ul><li><strong>优点：</strong> 增强代码可读性和可维护性、强大的 IDE 支持（智能提示）、编译期错误检查、利于大型项目重构。</li><li><strong>缺点：</strong> 增加学习成本、初期开发速度稍慢（需要写类型）、编译时间。</li></ul><p><strong>3. TypeScript 中的基本类型有哪些？</strong></p><ul><li><code>boolean</code>, <code>number</code>, <code>string</code>, <code>array</code>, <code>tuple</code>, <code>enum</code>, <code>any</code>, <code>void</code>, <code>null</code>, <code>undefined</code>, <code>never</code>, <code>object</code>。</li></ul><p><strong>4. <code>any</code> 和 <code>unknown</code> 的区别是什么？（高频）</strong></p><ul><li><strong>答案：</strong><ul><li><code>any</code>：绕过类型检查。任何类型都能赋值给 <code>any</code>，<code>any</code> 也能赋值给任何类型。使用它相当于放弃了 TS 的保护。</li><li><code>unknown</code>：类型安全的 <code>any</code>。任何类型都能赋值给 <code>unknown</code>，但 <code>unknown</code> 不能直接赋值给其他类型（除了 <code>any</code> 和 <code>unknown</code>），也不能调用其方法，除非先进行类型断言或类型收窄（Type Narrowing）。</li></ul></li></ul><p><strong>5. <code>void</code> 和 <code>undefined</code> 的区别？</strong></p><ul><li><code>void</code> 通常用于表示函数没有返回值。</li><li><code>undefined</code> 是一个具体的值（也是一种类型），表示变量已声明但未赋值。</li></ul><p><strong>6. 什么是 <code>never</code> 类型？何时使用？</strong></p><ul><li><strong>答案：</strong> <code>never</code> 表示永远不会存在的值的类型。</li><li><strong>场景：</strong><ul><li>抛出异常的函数（也就是函数无法执行结束）。</li><li>无限循环的函数。</li><li>在 Switch 语句中进行“全面性检查”（Exhaustiveness Check），确保所有 Union 类型都被处理。</li></ul></li></ul><p><strong>7. TypeScript 中 <code>enum</code>（枚举）的使用场景？</strong></p><ul><li><p>用于定义一组命名常量。分为数字枚举（默认从0自增）和字符串枚举。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Direction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Up</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Down</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul><p><strong>8. 元组（Tuple）和数组（Array）有什么区别？</strong></p><ul><li>数组通常用于存储相同类型的元素集合（<code>number[]</code>）。</li><li>元组用于存储固定数量和固定类型（可以是不同类型）的元素集合（<code>[string, number]</code>）。</li></ul><p><strong>9. 什么是类型断言（Type Assertion）？</strong></p><ul><li>当你比编译器更了解某个值的类型时，可以使用断言。</li><li>语法：<code>&lt;Type&gt;value</code> 或 <code>value as Type</code>（推荐后者，因为兼容 JSX）。</li></ul><p><strong>10. 什么是联合类型（Union Types）？</strong></p><ul><li>表示取值可以为多种类型中的一种。</li><li>语法：<code>let myVar: string | number;</code></li></ul><hr><h2 id="第二部分-接口与类型-interfaces-types" tabindex="-1">第二部分：接口与类型 (Interfaces &amp; Types) <a class="header-anchor" href="#第二部分-接口与类型-interfaces-types" aria-label="Permalink to &quot;第二部分：接口与类型 (Interfaces &amp; Types)&quot;">​</a></h2><p><strong>11. <code>interface</code> 和 <code>type</code> 的区别是什么？（超高频）</strong></p><ul><li><strong>答案：</strong><ul><li><strong>相同点：</strong> 都可以描述对象或函数、都支持扩展（extends/intersection）。</li><li><strong>不同点：</strong><ul><li><code>interface</code> 可以声明合并（Declaration Merging），即同名接口会自动合并；<code>type</code> 不行。</li><li><code>type</code> 可以声明基本类型别名、联合类型、元组等；<code>interface</code> 主要用于定义对象结构。</li><li>通常建议优先使用 <code>interface</code> 定义对象，需要复杂类型组合时使用 <code>type</code>。</li></ul></li></ul></li></ul><p><strong>12. 什么是可选属性（Optional Properties）？</strong></p><ul><li>在属性名后加 <code>?</code>，表示该属性可以不存在。</li></ul><p><strong>13. 什么是只读属性（Readonly properties）？</strong></p><ul><li>在属性名前加 <code>readonly</code>，初始化后不可修改。</li></ul><p><strong>14. 接口可以继承吗？</strong></p><ul><li>可以，使用 <code>extends</code> 关键字。接口支持多重继承。</li></ul><p><strong>15. 什么是索引签名（Index Signature）？</strong></p><ul><li><p>当不知道对象具体属性名，但知道 key 和 value 的类型时使用。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><hr><h2 id="第三部分-函数与类-functions-classes" tabindex="-1">第三部分：函数与类 (Functions &amp; Classes) <a class="header-anchor" href="#第三部分-函数与类-functions-classes" aria-label="Permalink to &quot;第三部分：函数与类 (Functions &amp; Classes)&quot;">​</a></h2><p><strong>16. 什么是函数重载（Function Overloading）？</strong></p><ul><li>允许为同一个函数提供多个函数类型定义，以便根据不同的参数类型或数量返回不同的结果。</li><li>注意：最终的实现签名必须兼容所有的重载签名。</li></ul><p><strong>17. 解释 TypeScript 中的 <code>public</code>、<code>private</code>、<code>protected</code>。</strong></p><ul><li><code>public</code>：默认，可以在任何地方访问。</li><li><code>private</code>：只能在定义它的类内部访问。</li><li><code>protected</code>：只能在定义它的类及其子类中访问。</li></ul><p><strong>18. 什么是抽象类（Abstract Class）？</strong></p><ul><li>不能被实例化的类，专门作为基类使用。可以包含实现细节，也可以包含抽象方法（强制子类实现）。</li></ul><p><strong>19. 什么是构造函数参数属性（Parameter Properties）？</strong></p><ul><li><p>一种简写语法，在构造函数参数前加修饰符，自动将其定义为类属性并赋值。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(public name: string) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于声明属性并赋值</span></span></code></pre></div></li></ul><p><strong>20. 什么是 <code>this</code> 参数在函数中的类型声明？</strong></p><ul><li>为了显式约束函数运行时 <code>this</code> 的指向，可以在函数第一个参数列表声明 <code>this</code> 的类型（编译后会被移除）。</li></ul><hr><h2 id="第四部分-泛型-generics-——-进阶核心" tabindex="-1">第四部分：泛型 (Generics) —— 进阶核心 <a class="header-anchor" href="#第四部分-泛型-generics-——-进阶核心" aria-label="Permalink to &quot;第四部分：泛型 (Generics) —— 进阶核心&quot;">​</a></h2><p><strong>21. 什么是泛型？为什么要使用它？</strong></p><ul><li><strong>答案：</strong> 泛型是指在定义函数、接口或类时，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</li><li><strong>作用：</strong> 提高代码复用性，同时保持类型安全（避免使用 <code>any</code>）。</li></ul><p><strong>22. 泛型约束（Generic Constraints）是什么？</strong></p><ul><li><p>使用 <code>extends</code> 关键字限制泛型必须符合某种结构。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须有 length 属性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><p><strong>23. 解释 <code>keyof</code> 操作符。</strong></p><ul><li><p>获取某种类型的所有键（key）的联合类型。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Keys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> keyof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;name&quot; | &quot;age&quot;</span></span></code></pre></div></li></ul><p><strong>24. 解释 <code>typeof</code> 操作符在 TS 中的用法。</strong></p><ul><li><p>JS 中用于获取运行时类型，TS 中用于获取变量或对象的<strong>类型结构</strong>。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// { name: string; age: number; }</span></span></code></pre></div></li></ul><hr><h2 id="第五部分-高级类型与工具类型-advanced-utility-types" tabindex="-1">第五部分：高级类型与工具类型 (Advanced &amp; Utility Types) <a class="header-anchor" href="#第五部分-高级类型与工具类型-advanced-utility-types" aria-label="Permalink to &quot;第五部分：高级类型与工具类型 (Advanced &amp; Utility Types)&quot;">​</a></h2><p><strong>25. 什么是交叉类型（Intersection Types）？</strong></p><ul><li>将多个类型合并为一个类型（取并集属性）。语法：<code>TypeA &amp; TypeB</code>。</li></ul><p><strong>26. 解释 <code>Partial&lt;T&gt;</code>。</strong></p><ul><li>将类型 T 的所有属性变为可选。</li></ul><p><strong>27. 解释 <code>Required&lt;T&gt;</code>。</strong></p><ul><li>将类型 T 的所有属性变为必选。</li></ul><p><strong>28. 解释 <code>Readonly&lt;T&gt;</code>。</strong></p><ul><li>将类型 T 的所有属性变为只读。</li></ul><p><strong>29. 解释 <code>Pick&lt;T, K&gt;</code>。</strong></p><ul><li>从类型 T 中挑选部分属性 K 来构造新类型。</li></ul><p><strong>30. 解释 <code>Omit&lt;T, K&gt;</code>。</strong></p><ul><li>从类型 T 中剔除属性 K，构造新类型。</li></ul><p><strong>31. 解释 <code>Record&lt;K, T&gt;</code>。</strong></p><ul><li>构造一个对象类型，其属性键为 K，属性值为 T。常用于映射对象。</li></ul><p><strong>32. 什么是类型守卫（Type Guards）？</strong></p><ul><li><p>在运行时检查类型以缩小类型范围。</p></li><li><p>方式：<code>typeof</code>，<code>instanceof</code>，以及自定义类型谓词（<code>parameter is Type</code>）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><p><strong>33. 什么是条件类型（Conditional Types）？</strong></p><ul><li>语法类似于三元运算符：<code>T extends U ? X : Y</code>。</li></ul><p><strong>34. <code>infer</code> 关键字的作用是什么？</strong></p><ul><li><p>在条件类型中用于推断类型变量。常用于提取函数返回值类型或数组元素类型。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> infer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ul><p><strong>35. 什么是 <code>Mapped Types</code>（映射类型）？</strong></p><ul><li><p>基于旧类型创建新类型的一种方式，通常结合 <code>keyof</code> 使用。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> keyof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><hr><h2 id="第六部分-配置与生态-config-ecosystem" tabindex="-1">第六部分：配置与生态 (Config &amp; Ecosystem) <a class="header-anchor" href="#第六部分-配置与生态-config-ecosystem" aria-label="Permalink to &quot;第六部分：配置与生态 (Config &amp; Ecosystem)&quot;">​</a></h2><p><strong>36. <code>tsconfig.json</code> 文件的作用？</strong></p><ul><li>指定编译该项目所需的根文件和编译选项。</li></ul><p><strong>37. 解释 <code>noImplicitAny</code> 选项。</strong></p><ul><li>当开启时，如果无法推断变量类型且未显式指定，TS 会报错（防止隐式 <code>any</code>）。</li></ul><p><strong>38. 解释 <code>strictNullChecks</code> 选项。</strong></p><ul><li>开启后，<code>null</code> 和 <code>undefined</code> 只能赋值给它们自己或 <code>any</code>（不能赋值给 number/string 等）。这是减少运行时 &quot;undefined is not a function&quot; 错误的关键配置。</li></ul><p><strong>39. 什么是 <code>.d.ts</code> 文件？</strong></p><ul><li>类型定义文件（Declaration Files）。它只包含类型信息，不包含逻辑代码，用于让 TS 识别 JS 库的类型。</li></ul><p><strong>40. 什么是 <code>const</code> 断言 (<code>as const</code>)？</strong></p><ul><li>告诉编译器该表达式是不可变的，将其推断为最窄的字面量类型，而不是宽泛的类型（例如推断为 <code>&quot;hello&quot;</code> 而不是 <code>string</code>，推断数组为 <code>readonly</code> 元组）。</li></ul><hr><h2 id="第七部分-实战场景题-scenario-based" tabindex="-1">第七部分：实战场景题 (Scenario Based) <a class="header-anchor" href="#第七部分-实战场景题-scenario-based" aria-label="Permalink to &quot;第七部分：实战场景题 (Scenario Based)&quot;">​</a></h2><p><strong>41. 如何让一个接口的部分属性变为可选，其他保持不变？</strong></p><ul><li>使用组合工具类型：<code>Pick&lt;T, K&gt; &amp; Partial&lt;Omit&lt;T, K&gt;&gt;</code> (或者直接手写映射类型)。</li></ul><p><strong>42. 如何获取 Promise 返回值的类型？</strong></p><ul><li><p>使用 <code>Awaited&lt;T&gt;</code> (TS 4.5+) 或自定义 <code>infer</code>。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyResult</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Awaited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// string</span></span></code></pre></div></li></ul><p><strong>43. 什么是非空断言操作符（!）？</strong></p><ul><li>后缀 <code>!</code>（如 <code>item!.name</code>），告诉编译器“我确定这个值不是 null 或 undefined”，强制跳过空值检查。慎用。</li></ul><p><strong>44. TypeScript 装饰器（Decorators）是什么？</strong></p><ul><li>一种特殊类型的声明，可以附加到类声明、方法、访问符、属性或参数上。本质上是高阶函数，用于元编程。</li></ul><p><strong>45. 什么是协变（Covariance）和逆变（Contravariance）？</strong></p><ul><li>这是较难的类型理论。简单来说： <ul><li><strong>对象/返回值是协变的</strong>：允许子类型赋值给父类型。</li><li><strong>函数参数是逆变的</strong>（在开启 strictFunctionTypes 时）：允许父类型赋值给子类型。</li></ul></li></ul><p><strong>46. 如何在 Window 对象上扩展全局属性？</strong></p><ul><li><p>使用声明合并（Declaration Merging）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    myCustomProp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><p><strong>47. <code>unknown</code> 类型如何安全使用？</strong></p><ul><li>必须在使用前进行类型收窄。例如使用 <code>if (typeof val === &#39;string&#39;) { ... }</code>。</li></ul><p><strong>48. 什么是 <code>Module Augmentation</code>？</strong></p><ul><li>用于扩展第三方库的类型定义。</li></ul><p><strong>49. 解释 <code>Exclude&lt;T, U&gt;</code> 和 <code>Extract&lt;T, U&gt;</code>。</strong></p><ul><li><code>Exclude</code>：从 T 中排除可以赋值给 U 的类型。</li><li><code>Extract</code>：从 T 中提取可以赋值给 U 的类型。</li></ul><p><strong>50. TypeScript 5.0+ 有什么新特性？</strong></p><ul><li>装饰器标准实现（Stage 3 Decorators）、<code>const</code> 类型参数、性能优化等。</li></ul><p><em>(此处为了篇幅，精选了50道最具代表性的题目，掌握这些足以应对 90% 的 TypeScript 面试。所谓的“100题”通常是这些知识点的变种或拆分。)</em></p><hr><h3 id="💡-如何将此内容保存为-pdf" tabindex="-1">💡 如何将此内容保存为 PDF？ <a class="header-anchor" href="#💡-如何将此内容保存为-pdf" aria-label="Permalink to &quot;💡 如何将此内容保存为 PDF？&quot;">​</a></h3><ol><li><strong>全选</strong> 上面的文字内容。</li><li><strong>粘贴</strong> 到 Markdown 编辑器（如 Typora, Obsidian）或 Word 文档中。</li><li>如果使用 Chrome 浏览器，也可以直接右键点击页面 -&gt; 选择 <strong>打印</strong> -&gt; 目标打印机选择 <strong>&quot;另存为 PDF&quot;</strong>。</li></ol><p>祝你面试顺利！</p>`,123)])])}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
